{
	"type": "meshLambertBuilder",
	"nodes": {
		"globals1": {
			"type": "globals"
		},
		"output1": {
			"type": "output",
			"inputs": [
				null,
				null,
				{
					"index": 2,
					"node": "vec4ToVec3_1",
					"output": "vec3"
				}
			]
		},
		"texture1": {
			"type": "texture",
			"params": {
				"paramName": "texBaseColor",
				"uv": {
					"overriden_options": {}
				},
				"blurPixelsCountX": {
					"overriden_options": {}
				},
				"blurPixelsCountY": {
					"overriden_options": {}
				}
			},
			"inputs": [
				{
					"index": 0,
					"node": "globals1",
					"output": "uv"
				}
			]
		},
		"vec4ToVec3_1": {
			"type": "vec4ToVec3",
			"params": {
				"vec4": {
					"overriden_options": {}
				}
			},
			"inputs": [
				{
					"index": 0,
					"node": "colorCorrect1",
					"output": "out"
				}
			]
		},
		"colorCorrect1": {
			"type": "colorCorrect",
			"params": {
				"color": {
					"overriden_options": {}
				},
				"from": 1,
				"to": 0
			},
			"inputs": [
				{
					"index": 0,
					"node": "texture1",
					"output": "rgba"
				}
			]
		}
	},
	"params": {
		"textureMap": {
			"type": "node_path",
			"default_value": "/COP/imageUv",
			"options": {
				"nodeSelection": {
					"context": "cop"
				},
				"spare": true,
				"computeOnDirty": true,
				"cook": false
			},
			"raw_input": "/COP/dinosaur1"
		},
		"texBaseColor": {
			"type": "node_path",
			"default_value": "",
			"options": {
				"spare": true,
				"computeOnDirty": true,
				"cook": false,
				"dependentOnFoundNode": true,
				"nodeSelection": {
					"context": "cop"
				}
			},
			"raw_input": "/COP/dinosaur1",
			"overriden_options": {
				"callback": "{}",
				"nodeSelection": "{\"context\":\"cop\"}"
			}
		}
	},
	"persisted_config": {
		"material": {
			"metadata": {
				"version": 4.5,
				"type": "Material",
				"generator": "Material.toJSON"
			},
			"uuid": "/geo1/MAT/meshLambertBuilder_dinosaur1-main",
			"type": "MeshLambertMaterial",
			"name": "/geo1/MAT/meshLambertBuilder_dinosaur1",
			"color": 16777215,
			"emissive": 0,
			"reflectivity": 1,
			"refractionRatio": 0.98,
			"depthFunc": 3,
			"depthTest": true,
			"depthWrite": true,
			"colorWrite": true,
			"stencilWrite": false,
			"stencilWriteMask": 255,
			"stencilFunc": 519,
			"stencilRef": 0,
			"stencilFuncMask": 255,
			"stencilFail": 7680,
			"stencilZFail": 7680,
			"stencilZPass": 7680
		},
		"onBeforeCompileDataJSON": {
			"vertexShader": "\n#define LAMBERT\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\n\tv_POLY_globals1_uv = vec2(uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\n// removed:\n//\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n// removed:\n//\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
			"fragmentShader": "\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\nuniform sampler2D v_POLY_texture_texBaseColor;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\n\tvec4 v_POLY_texture1_rgba = texture2D(v_POLY_texture_texBaseColor, v_POLY_globals1_uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n\tvec4 v_POLY_colorCorrect1_out = sRGBToLinear(v_POLY_texture1_rgba);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/vec4ToVec3_1\n\tvec3 v_POLY_vec4ToVec3_1_vec3 = v_POLY_colorCorrect1_out.xyz;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tdiffuseColor.xyz = v_POLY_vec4ToVec3_1_vec3;\n\n\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t#endif\n\n\t#include <lightmap_fragment>\n\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t#else\n\n\t\treflectedLight.directDiffuse = vLightFront;\n\n\t#endif\n\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t// modulation\n\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
			"timeDependent": false,
			"resolutionDependent": false,
			"paramConfigs": [
				{
					"type": "node_path",
					"name": "texBaseColor",
					"defaultValue": "",
					"uniformName": "v_POLY_texture_texBaseColor"
				}
			]
		},
		"customMaterials": {
			"customDepthMaterial": {
				"material": {
					"metadata": {
						"version": 4.5,
						"type": "Material",
						"generator": "Material.toJSON"
					},
					"uuid": "/geo1/MAT/meshLambertBuilder_dinosaur1-customDepthMaterial",
					"type": "MeshDepthMaterial",
					"name": "customDepthMaterial",
					"depthFunc": 3,
					"depthTest": true,
					"depthWrite": true,
					"colorWrite": true,
					"stencilWrite": false,
					"stencilWriteMask": 255,
					"stencilFunc": 519,
					"stencilRef": 0,
					"stencilFuncMask": 255,
					"stencilFail": 7680,
					"stencilZFail": 7680,
					"stencilZPass": 7680,
					"depthPacking": 3201
				},
				"onBeforeCompileDataJSON": {
					"vertexShader": "\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.\n// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for\n// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\n\tv_POLY_globals1_uv = vec2(uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvHighPrecisionZW = gl_Position.zw;\n\n}\n",
					"fragmentShader": "\n// INSERT DEFINES\n\n\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\nuniform sampler2D v_POLY_texture_texBaseColor;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\n\tvec4 v_POLY_texture1_rgba = texture2D(v_POLY_texture_texBaseColor, v_POLY_globals1_uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n\tvec4 v_POLY_colorCorrect1_out = sRGBToLinear(v_POLY_texture1_rgba);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/vec4ToVec3_1\n\tvec3 v_POLY_vec4ToVec3_1_vec3 = v_POLY_colorCorrect1_out.xyz;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tdiffuseColor.xyz = v_POLY_vec4ToVec3_1_vec3;\n\n\n\n\n\t// INSERT BODY\n\t// the new body lines should be added before the alphatest_fragment\n\t// so that alpha is set before (which is really how it would be set if the alphamap_fragment above was used by the material node parameters)\n\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), diffuseColor.a );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n",
					"timeDependent": false,
					"resolutionDependent": false,
					"paramConfigs": [
						{
							"type": "node_path",
							"name": "texBaseColor",
							"defaultValue": "",
							"uniformName": "v_POLY_texture_texBaseColor"
						}
					]
				}
			},
			"customDistanceMaterial": {
				"material": {
					"metadata": {
						"version": 4.5,
						"type": "Material",
						"generator": "Material.toJSON"
					},
					"uuid": "/geo1/MAT/meshLambertBuilder_dinosaur1-customDistanceMaterial",
					"type": "MeshDistanceMaterial",
					"name": "customDistanceMaterial",
					"depthFunc": 3,
					"depthTest": true,
					"depthWrite": true,
					"colorWrite": true,
					"stencilWrite": false,
					"stencilWriteMask": 255,
					"stencilFunc": 519,
					"stencilRef": 0,
					"stencilFuncMask": 255,
					"stencilFail": 7680,
					"stencilZFail": 7680,
					"stencilZPass": 7680
				},
				"onBeforeCompileDataJSON": {
					"vertexShader": "\n#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\n\tv_POLY_globals1_uv = vec2(uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvWorldPosition = worldPosition.xyz;\n\n}\n",
					"fragmentShader": "\n// INSERT DEFINES\n\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\nuniform sampler2D v_POLY_texture_texBaseColor;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\n\tvec4 v_POLY_texture1_rgba = texture2D(v_POLY_texture_texBaseColor, v_POLY_globals1_uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n\tvec4 v_POLY_colorCorrect1_out = sRGBToLinear(v_POLY_texture1_rgba);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/vec4ToVec3_1\n\tvec3 v_POLY_vec4ToVec3_1_vec3 = v_POLY_colorCorrect1_out.xyz;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tdiffuseColor.xyz = v_POLY_vec4ToVec3_1_vec3;\n\n\n\n\n\t// INSERT BODY\n\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n",
					"timeDependent": false,
					"resolutionDependent": false,
					"paramConfigs": [
						{
							"type": "node_path",
							"name": "texBaseColor",
							"defaultValue": "",
							"uniformName": "v_POLY_texture_texBaseColor"
						}
					]
				}
			},
			"customDepthDOFMaterial": {
				"material": {
					"metadata": {
						"version": 4.5,
						"type": "Material",
						"generator": "Material.toJSON"
					},
					"uuid": "/geo1/MAT/meshLambertBuilder_dinosaur1-customDepthDOFMaterial",
					"type": "MeshDepthMaterial",
					"name": "customDepthDOFMaterial",
					"depthFunc": 3,
					"depthTest": true,
					"depthWrite": true,
					"colorWrite": true,
					"stencilWrite": false,
					"stencilWriteMask": 255,
					"stencilFunc": 519,
					"stencilRef": 0,
					"stencilFuncMask": 255,
					"stencilFail": 7680,
					"stencilZFail": 7680,
					"stencilZPass": 7680,
					"depthPacking": 3200
				},
				"onBeforeCompileDataJSON": {
					"vertexShader": "\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.\n// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for\n// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\n\tv_POLY_globals1_uv = vec2(uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvHighPrecisionZW = gl_Position.zw;\n\n}\n",
					"fragmentShader": "\n// INSERT DEFINES\n\n\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\nuniform sampler2D v_POLY_texture_texBaseColor;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\n\tvec4 v_POLY_texture1_rgba = texture2D(v_POLY_texture_texBaseColor, v_POLY_globals1_uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n\tvec4 v_POLY_colorCorrect1_out = sRGBToLinear(v_POLY_texture1_rgba);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/vec4ToVec3_1\n\tvec3 v_POLY_vec4ToVec3_1_vec3 = v_POLY_colorCorrect1_out.xyz;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tdiffuseColor.xyz = v_POLY_vec4ToVec3_1_vec3;\n\n\n\n\n\t// INSERT BODY\n\t// the new body lines should be added before the alphatest_fragment\n\t// so that alpha is set before (which is really how it would be set if the alphamap_fragment above was used by the material node parameters)\n\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), diffuseColor.a );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n",
					"timeDependent": false,
					"resolutionDependent": false,
					"paramConfigs": [
						{
							"type": "node_path",
							"name": "texBaseColor",
							"defaultValue": "",
							"uniformName": "v_POLY_texture_texBaseColor"
						}
					]
				}
			}
		}
	}
}