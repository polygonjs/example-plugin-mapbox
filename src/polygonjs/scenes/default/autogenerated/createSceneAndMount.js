import {loadScene_default} from './loadScene.js';

export const createSceneAndMount_default = async function (options={}) {
	if(options && options.createViewer == null){
		options.createViewer = true;
	}
	options.sceneData = {"properties":{"frame":238,"maxFrame":600,"maxFrameLocked":false,"realtimeState":true,"mainCameraPath":"/mapboxCamera1","versions":{"polygonjs":"1.2.30"}},"root":{"type":"root","nodes":{"mapboxCamera1":{"type":"mapboxCamera","params":{"bearing":309.6,"tlayerBuildings":1}},"hemisphereLight1":{"type":"hemisphereLight","flags":{"display":true}},"geo1":{"type":"geo","nodes":{"add1":{"type":"add"},"transform1":{"type":"transform","params":{"t":[-0.07956,0,51.5146]},"inputs":["add1"]},"copy1":{"type":"copy","inputs":["material1","mapboxTransform1"]},"mapboxTransform1":{"type":"mapboxTransform","params":{"mapboxCamera":"../../mapboxCamera1"},"inputs":["transform1"]},"transform2":{"type":"transform","params":{"scale":10},"inputs":["restAttributes1"]},"file1":{"type":"fileGLTF","params":{"url":"/models/dinosaur1.glb"}},"hierarchy1":{"type":"hierarchy","params":{"mode":1},"inputs":["file1"]},"objectProperties1":{"type":"objectProperties","params":{"tcastShadow":1,"castShadow":0,"treceiveShadow":1,"receiveShadow":0},"inputs":["transform2"]},"material1":{"type":"material","params":{"material":"/geo1/MAT/meshLambertBuilder_dinosaur1"},"inputs":["objectProperties1"]},"restAttributes1":{"type":"restAttributes","params":{"tnormal":0},"inputs":["hierarchy1"]},"file2":{"type":"fileGLTF","params":{"url":"/models/dinosaur2.glb"}},"hierarchy2":{"type":"hierarchy","params":{"mode":1},"inputs":["file2"]},"transform3":{"type":"transform","params":{"scale":10},"inputs":["restAttributes2"]},"objectProperties2":{"type":"objectProperties","params":{"tcastShadow":true,"castShadow":false,"treceiveShadow":true,"receiveShadow":false},"inputs":["transform3"]},"restAttributes2":{"type":"restAttributes","params":{"tnormal":false},"inputs":["transform6"]},"transform4":{"type":"transform","params":{"t":[-0.07956,0,51.514500000000005]},"inputs":["transform5"]},"mapboxTransform2":{"type":"mapboxTransform","params":{"mapboxCamera":"../../mapboxCamera1"},"inputs":["transform4"]},"merge1":{"type":"merge","inputs":["copy1","instance1"]},"hexagons1":{"type":"hexagons","params":{"size":[8,8],"pointsOnly":1}},"transform5":{"type":"transform","params":{"scale":0.007},"inputs":["transform8"]},"normals1":{"type":"normals","params":{"edit":1,"updateX":1,"x":"@P.x","updateY":1,"y":0,"updateZ":1,"z":"-@P.z","invert":1},"inputs":["point_set_Py_to_0"]},"transform6":{"type":"transform","params":{"r":[0,170,0]},"inputs":["hierarchy2"]},"transform8":{"type":"transform","params":{"scale":1.9},"inputs":["attribCreate2"]},"delete_points_close_to_center":{"type":"delete","params":{"byExpression":1,"expression":"abs(@P.x) < 0.1 && abs(@P.z) < 0.1"},"inputs":["normals1"]},"jitter1":{"type":"jitter","params":{"amount":0.05},"inputs":["hexagons1"]},"point_set_Py_to_0":{"type":"point","params":{"updateY":1,"y":0},"inputs":["jitter1"]},"instance1":{"type":"instance","params":{"attributesToCopy":"instance* id dist","material":"/geo1/MAT/meshLambertBuilder_dinosaur2"},"inputs":["objectProperties2","mapboxTransform2"]},"attribCreate1":{"type":"attribCreate","params":{"name":"id","value1":"@ptnum"},"inputs":["delete_points_close_to_center"]},"attribCreate2":{"type":"attribCreate","params":{"name":"dist","value1":"sqrt(@P.x*@P.x + @P.z*@P.z)"},"inputs":["attribCreate1"]},"OUT":{"type":"null","inputs":["merge1"],"flags":{"display":true}},"MAT":{"type":"materialsNetwork","nodes":{"meshLambertBuilder_dinosaur1":{"type":"meshLambertBuilder","nodes":{"globals1":{"type":"globals"},"output1":{"type":"output","inputs":[null,null,{"index":2,"node":"vec4ToVec3_1","output":"vec3"}]},"texture1":{"type":"texture","params":{"paramName":"texBaseColor","uv":{"overriden_options":{}},"blurPixelsCountX":{"overriden_options":{}},"blurPixelsCountY":{"overriden_options":{}}},"inputs":[{"index":0,"node":"globals1","output":"uv"}]},"vec4ToVec3_1":{"type":"vec4ToVec3","params":{"vec4":{"overriden_options":{}}},"inputs":[{"index":0,"node":"colorCorrect1","output":"out"}]},"colorCorrect1":{"type":"colorCorrect","params":{"color":{"overriden_options":{}},"from":1,"to":0},"inputs":[{"index":0,"node":"texture1","output":"rgba"}]}},"params":{"textureMap":{"type":"node_path","default_value":"/COP/imageUv","options":{"nodeSelection":{"context":"cop"},"spare":true,"computeOnDirty":true,"cook":false},"raw_input":"/COP/dinosaur1"},"texBaseColor":{"type":"node_path","default_value":"","options":{"spare":true,"computeOnDirty":true,"cook":false,"dependentOnFoundNode":true,"nodeSelection":{"context":"cop"}},"raw_input":"/COP/dinosaur1","overriden_options":{"callback":"{}","nodeSelection":"{\"context\":\"cop\"}"}}},"persisted_config":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/geo1/MAT/meshLambertBuilder_dinosaur1-main","type":"MeshLambertMaterial","name":"/geo1/MAT/meshLambertBuilder_dinosaur1","color":16777215,"emissive":0,"reflectivity":1,"refractionRatio":0.98,"depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680,"fog":false},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[{"type":"node_path","name":"texBaseColor","defaultValue":"","uniformName":"v_POLY_texture_texBaseColor"}],"timeDependent":false,"resolutionDependent":false},"customMaterials":{"customDepthMaterial":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/geo1/MAT/meshLambertBuilder_dinosaur1-customDepthMaterial","type":"MeshDepthMaterial","name":"customDepthMaterial","depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680,"depthPacking":3201},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[{"type":"node_path","name":"texBaseColor","defaultValue":"","uniformName":"v_POLY_texture_texBaseColor"}],"timeDependent":false,"resolutionDependent":false}},"customDistanceMaterial":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/geo1/MAT/meshLambertBuilder_dinosaur1-customDistanceMaterial","type":"MeshDistanceMaterial","name":"customDistanceMaterial","depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[{"type":"node_path","name":"texBaseColor","defaultValue":"","uniformName":"v_POLY_texture_texBaseColor"}],"timeDependent":false,"resolutionDependent":false}},"customDepthDOFMaterial":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/geo1/MAT/meshLambertBuilder_dinosaur1-customDepthDOFMaterial","type":"MeshDepthMaterial","name":"customDepthDOFMaterial","depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680,"depthPacking":3200},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[{"type":"node_path","name":"texBaseColor","defaultValue":"","uniformName":"v_POLY_texture_texBaseColor"}],"timeDependent":false,"resolutionDependent":false}}}}},"meshLambertBuilder_dinosaur2":{"type":"meshLambertBuilder","nodes":{"colorCorrect1":{"type":"colorCorrect","params":{"color":{"overriden_options":{}},"from":1,"to":0},"inputs":[{"index":0,"node":"texture1","output":"rgba"}]},"globals1":{"type":"globals"},"output1":{"type":"output","inputs":[{"index":0,"node":"instanceTransform1","output":"position"},{"index":1,"node":"instanceTransform1","output":"normal"},{"index":2,"node":"vec4ToVec3_1","output":"vec3"},{"index":3,"node":"twoWaySwitch1","output":"val"}]},"texture1":{"type":"texture","params":{"paramName":"texBaseColor","uv":{"overriden_options":{}},"blurPixelsCountX":{"overriden_options":{}},"blurPixelsCountY":{"overriden_options":{}}},"inputs":[{"index":0,"node":"globals1","output":"uv"}]},"vec4ToVec3_1":{"type":"vec4ToVec3","params":{"vec4":{"overriden_options":{}}},"inputs":[{"index":0,"node":"colorCorrect1","output":"out"}]},"instanceTransform1":{"type":"instanceTransform","params":{"position":{"overriden_options":{}},"normal":{"overriden_options":{}},"instancePosition":{"overriden_options":{}},"instanceOrientation":{"overriden_options":{}},"instanceScale":{"overriden_options":{}}},"inputs":[null,null,null,null,{"index":4,"node":"floatToVec3_1","output":"vec3"}]},"attribute1":{"type":"attribute","params":{"name":"id"},"connection_points":{"in":[],"out":[{"name":"val","type":"float"}]}},"floatToVec2_1":{"type":"floatToVec2","params":{"x":{"overriden_options":{}},"y":{"raw_input":56,"overriden_options":{}}},"inputs":[{"index":0,"node":"round1","output":"val"}]},"round1":{"type":"round","params":{"in":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}}},"inputs":[{"index":0,"node":"attribute1","output":"val"}],"connection_points":{"in":[{"name":"in","type":"float"}],"out":[{"name":"val","type":"float"}]}},"random1":{"type":"random","params":{"seed":{"overriden_options":{}}},"inputs":[{"index":0,"node":"floatToVec2_1","output":"vec2"}]},"fitFrom01ToVariance1":{"type":"fitFrom01ToVariance","params":{"val":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"center":{"type":"float","default_value":0.5,"options":{"spare":true,"editable":true},"raw_input":1},"variance":{"type":"float","default_value":0.5,"options":{"spare":true,"editable":true},"raw_input":0.34}},"inputs":[{"index":0,"node":"random1","output":"rand"}],"connection_points":{"in":[{"name":"val","type":"float"},{"name":"center","type":"float"},{"name":"variance","type":"float"}],"out":[{"name":"val","type":"float"}]}},"floatToVec3_1":{"type":"floatToVec3","params":{"x":{"overriden_options":{}},"y":{"overriden_options":{}},"z":{"overriden_options":{}}},"inputs":[{"index":0,"node":"fitFrom01ToVariance1","output":"val"},{"index":1,"node":"fitFrom01ToVariance1","output":"val"},{"index":2,"node":"fitFrom01ToVariance1","output":"val"}]},"vec3ToFloat1":{"type":"vec3ToFloat","params":{"vec":{"overriden_options":{}}},"inputs":[{"index":0,"node":"attribute2","output":"val"}]},"attribute2":{"type":"attribute","params":{"name":"restP","type":2},"connection_points":{"in":[],"out":[{"name":"val","type":"vec3"}]}},"twoWaySwitch1":{"type":"twoWaySwitch","params":{"condition":{"type":"boolean","default_value":false,"options":{"spare":true,"editable":false}},"ifTrue":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}},"ifFalse":{"type":"float","default_value":0,"options":{"spare":true,"editable":true},"raw_input":1}},"inputs":[{"index":0,"node":"compare2","output":"val"}],"connection_points":{"in":[{"name":"condition","type":"bool"},{"name":"ifTrue","type":"float"},{"name":"ifFalse","type":"float"}],"out":[{"name":"val","type":"float"}]}},"compare1":{"type":"compare","params":{"value0":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"value1":{"type":"float","default_value":0,"options":{"spare":true,"editable":true},"raw_input":1}},"inputs":[{"index":0,"node":"vec3ToFloat1","output":"y"}],"connection_points":{"in":[{"name":"value0","type":"float"},{"name":"value1","type":"float"}],"out":[{"name":"val","type":"bool"}]}},"attribute3":{"type":"attribute","params":{"name":"dist"},"connection_points":{"in":[],"out":[{"name":"val","type":"float"}]}},"globals2":{"type":"globals"},"multAdd1":{"type":"multAdd","params":{"value":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"preAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}},"mult":{"type":"float","default_value":1,"options":{"spare":true,"editable":true}},"postAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}}},"inputs":[{"index":0,"node":"globals2","output":"time"}],"connection_points":{"in":[{"name":"value","type":"float"},{"name":"preAdd","type":"float"},{"name":"mult","type":"float"},{"name":"postAdd","type":"float"}],"out":[{"name":"val","type":"float"}]}},"compare2":{"type":"compare","params":{"test":2,"value0":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"value1":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}}},"inputs":[{"index":0,"node":"add1","output":"sum"},{"index":1,"node":"multAdd1","output":"val"}],"connection_points":{"in":[{"name":"value0","type":"float"},{"name":"value1","type":"float"}],"out":[{"name":"val","type":"bool"}]}},"add1":{"type":"add","params":{"add0":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"add1":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"add2":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}}},"maxInputsCount":3,"inputs":[{"index":0,"node":"multAdd2","output":"val"},{"index":1,"node":"multAdd5","output":"val"}],"connection_points":{"in":[{"name":"add0","type":"float"},{"name":"add1","type":"float"},{"name":"add2","type":"float"}],"out":[{"name":"sum","type":"float"}]}},"multAdd2":{"type":"multAdd","params":{"value":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"preAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}},"mult":{"type":"float","default_value":1,"options":{"spare":true,"editable":true},"raw_input":-0.30000000000000004},"postAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}}},"inputs":[{"index":0,"node":"vec3ToFloat1","output":"z"}],"connection_points":{"in":[{"name":"value","type":"float"},{"name":"preAdd","type":"float"},{"name":"mult","type":"float"},{"name":"postAdd","type":"float"}],"out":[{"name":"val","type":"float"}]}},"multAdd3":{"type":"multAdd","params":{"value":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"preAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}},"mult":{"type":"float","default_value":1,"options":{"spare":true,"editable":true},"raw_input":4.6},"postAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}}},"inputs":[{"index":0,"node":"attribute3","output":"val"}],"connection_points":{"in":[{"name":"value","type":"float"},{"name":"preAdd","type":"float"},{"name":"mult","type":"float"},{"name":"postAdd","type":"float"}],"out":[{"name":"val","type":"float"}]}},"attribute4":{"type":"attribute","params":{"name":"id"},"connection_points":{"in":[],"out":[{"name":"val","type":"float"}]}},"floatToVec2_2":{"type":"floatToVec2","params":{"x":{"overriden_options":{}},"y":{"raw_input":56,"overriden_options":{}}},"inputs":[{"index":0,"node":"round2","output":"val"}]},"round2":{"type":"round","params":{"in":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}}},"inputs":[{"index":0,"node":"attribute4","output":"val"}],"connection_points":{"in":[{"name":"in","type":"float"}],"out":[{"name":"val","type":"float"}]}},"random2":{"type":"random","params":{"seed":{"overriden_options":{}}},"inputs":[{"index":0,"node":"floatToVec2_2","output":"vec2"}]},"fitFrom01ToVariance2":{"type":"fitFrom01ToVariance","params":{"val":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"center":{"type":"float","default_value":0.5,"options":{"spare":true,"editable":true},"raw_input":0},"variance":{"type":"float","default_value":0.5,"options":{"spare":true,"editable":true},"raw_input":1}},"inputs":[{"index":0,"node":"random2","output":"rand"}],"connection_points":{"in":[{"name":"val","type":"float"},{"name":"center","type":"float"},{"name":"variance","type":"float"}],"out":[{"name":"val","type":"float"}]}},"add2":{"type":"add","params":{"add0":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"add1":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"add2":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}}},"maxInputsCount":3,"inputs":[{"index":0,"node":"multAdd3","output":"val"},{"index":1,"node":"multAdd4","output":"val"}],"connection_points":{"in":[{"name":"add0","type":"float"},{"name":"add1","type":"float"},{"name":"add2","type":"float"}],"out":[{"name":"sum","type":"float"}]}},"multAdd4":{"type":"multAdd","params":{"value":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"preAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}},"mult":{"type":"float","default_value":1,"options":{"spare":true,"editable":true}},"postAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}}},"inputs":[{"index":0,"node":"fitFrom01ToVariance2","output":"val"}],"connection_points":{"in":[{"name":"value","type":"float"},{"name":"preAdd","type":"float"},{"name":"mult","type":"float"},{"name":"postAdd","type":"float"}],"out":[{"name":"val","type":"float"}]}},"multAdd5":{"type":"multAdd","params":{"value":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"preAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}},"mult":{"type":"float","default_value":1,"options":{"spare":true,"editable":true}},"postAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true},"raw_input":0.9}},"inputs":[{"index":0,"node":"add2","output":"sum"}],"connection_points":{"in":[{"name":"value","type":"float"},{"name":"preAdd","type":"float"},{"name":"mult","type":"float"},{"name":"postAdd","type":"float"}],"out":[{"name":"val","type":"float"}]}}},"params":{"transparent":1,"textureMap":{"type":"node_path","default_value":"/COP/imageUv","options":{"nodeSelection":{"context":"cop"},"spare":true,"computeOnDirty":true,"cook":false},"raw_input":"/COP/dinosaur2"},"texBaseColor":{"type":"node_path","default_value":"","options":{"spare":true,"computeOnDirty":true,"cook":false,"dependentOnFoundNode":true,"nodeSelection":{"context":"cop"}},"raw_input":"/COP/dinosaur2","overriden_options":{"callback":"{}","nodeSelection":"{\"context\":\"cop\"}"}}},"persisted_config":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/geo1/MAT/meshLambertBuilder_dinosaur2-main","type":"MeshLambertMaterial","name":"/geo1/MAT/meshLambertBuilder_dinosaur2","color":16777215,"emissive":0,"reflectivity":1,"refractionRatio":0.98,"transparent":true,"depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680,"fog":false},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[{"type":"node_path","name":"texBaseColor","defaultValue":"","uniformName":"v_POLY_texture_texBaseColor"}],"timeDependent":true,"resolutionDependent":false},"customMaterials":{"customDepthMaterial":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/geo1/MAT/meshLambertBuilder_dinosaur2-customDepthMaterial","type":"MeshDepthMaterial","name":"customDepthMaterial","depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680,"depthPacking":3201},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[{"type":"node_path","name":"texBaseColor","defaultValue":"","uniformName":"v_POLY_texture_texBaseColor"}],"timeDependent":true,"resolutionDependent":false}},"customDistanceMaterial":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/geo1/MAT/meshLambertBuilder_dinosaur2-customDistanceMaterial","type":"MeshDistanceMaterial","name":"customDistanceMaterial","depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[{"type":"node_path","name":"texBaseColor","defaultValue":"","uniformName":"v_POLY_texture_texBaseColor"}],"timeDependent":true,"resolutionDependent":false}},"customDepthDOFMaterial":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/geo1/MAT/meshLambertBuilder_dinosaur2-customDepthDOFMaterial","type":"MeshDepthMaterial","name":"customDepthDOFMaterial","depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680,"depthPacking":3200},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[{"type":"node_path","name":"texBaseColor","defaultValue":"","uniformName":"v_POLY_texture_texBaseColor"}],"timeDependent":true,"resolutionDependent":false}}}}}}}},"flags":{"display":true}},"COP":{"type":"copNetwork","nodes":{"dinosaur1":{"type":"image","params":{"url":"/tex/dinosaur1.png?`js('Date.now()')`"}},"dinosaur2":{"type":"image","params":{"url":"/tex/dinosaur2.jpeg?`js('Date.now()')`"}}}},"perspectiveCamera1":{"type":"perspectiveCamera","nodes":{"events1":{"type":"eventsNetwork","nodes":{"cameraOrbitControls1":{"type":"cameraOrbitControls"}}}},"params":{"t":[1.1138879980300065,1.5669728061052821,0.7131541475759242],"r":[-65.52896628672457,32.902788078561464,50.04310153151484],"controls":"/perspectiveCamera1/events1/cameraOrbitControls1"},"flags":{"display":true}}},"params":{"backgroundMode":0,"mainCameraPath":"/mapboxCamera1"}},"shaders":{"/geo1/MAT/meshLambertBuilder_dinosaur1":{"vertex":"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\n\tv_POLY_globals1_uv = vec2(uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphcolor_vertex>\n// removed:\n//\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n// removed:\n//\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}","fragment":"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\nuniform sampler2D v_POLY_texture_texBaseColor;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\n\tvec4 v_POLY_texture1_rgba = texture2D(v_POLY_texture_texBaseColor, v_POLY_globals1_uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n\tvec4 v_POLY_colorCorrect1_out = sRGBToLinear(v_POLY_texture1_rgba);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/vec4ToVec3_1\n\tvec3 v_POLY_vec4ToVec3_1_vec3 = v_POLY_colorCorrect1_out.xyz;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tdiffuseColor.xyz = v_POLY_vec4ToVec3_1_vec3;\n\n\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}","customDepthMaterial.vertex":"#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\n\tv_POLY_globals1_uv = vec2(uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}","customDepthMaterial.fragment":"\n// INSERT DEFINES\n\n\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\nuniform sampler2D v_POLY_texture_texBaseColor;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\n\tvec4 v_POLY_texture1_rgba = texture2D(v_POLY_texture_texBaseColor, v_POLY_globals1_uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n\tvec4 v_POLY_colorCorrect1_out = sRGBToLinear(v_POLY_texture1_rgba);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/vec4ToVec3_1\n\tvec3 v_POLY_vec4ToVec3_1_vec3 = v_POLY_colorCorrect1_out.xyz;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tdiffuseColor.xyz = v_POLY_vec4ToVec3_1_vec3;\n\n\n\n\n\t// INSERT BODY\n\t// the new body lines should be added before the alphatest_fragment\n\t// so that alpha is set before (which is really how it would be set if the alphamap_fragment above was used by the material node parameters)\n\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), diffuseColor.a );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n","customDistanceMaterial.vertex":"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\n\tv_POLY_globals1_uv = vec2(uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}","customDistanceMaterial.fragment":"\n// INSERT DEFINES\n\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\nuniform sampler2D v_POLY_texture_texBaseColor;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\n\tvec4 v_POLY_texture1_rgba = texture2D(v_POLY_texture_texBaseColor, v_POLY_globals1_uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n\tvec4 v_POLY_colorCorrect1_out = sRGBToLinear(v_POLY_texture1_rgba);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/vec4ToVec3_1\n\tvec3 v_POLY_vec4ToVec3_1_vec3 = v_POLY_colorCorrect1_out.xyz;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tdiffuseColor.xyz = v_POLY_vec4ToVec3_1_vec3;\n\n\n\n\n\t// INSERT BODY\n\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n","customDepthDOFMaterial.vertex":"#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\n\tv_POLY_globals1_uv = vec2(uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}","customDepthDOFMaterial.fragment":"\n// INSERT DEFINES\n\n\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\nuniform sampler2D v_POLY_texture_texBaseColor;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur1/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/texture1\n\tvec4 v_POLY_texture1_rgba = texture2D(v_POLY_texture_texBaseColor, v_POLY_globals1_uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/colorCorrect1\n\tvec4 v_POLY_colorCorrect1_out = sRGBToLinear(v_POLY_texture1_rgba);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/vec4ToVec3_1\n\tvec3 v_POLY_vec4ToVec3_1_vec3 = v_POLY_colorCorrect1_out.xyz;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur1/output1\n\tdiffuseColor.xyz = v_POLY_vec4ToVec3_1_vec3;\n\n\n\n\n\t// INSERT BODY\n\t// the new body lines should be added before the alphatest_fragment\n\t// so that alpha is set before (which is really how it would be set if the alphamap_fragment above was used by the material node parameters)\n\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), diffuseColor.a );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n"},"/geo1/MAT/meshLambertBuilder_dinosaur2":{"vertex":"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance1\n//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/instanceTransform1\n\n\n// https://stackoverflow.com/questions/23793698/how-to-implement-slerp-in-glsl-hlsl\n// vec4 quatSlerp(vec4 p0, vec4 p1, float t)\n// {\n// \tfloat dotp = dot(normalize(p0), normalize(p1));\n// \tif ((dotp > 0.9999) || (dotp < -0.9999))\n// \t{\n// \t\tif (t<=0.5)\n// \t\t\treturn p0;\n// \t\treturn p1;\n// \t}\n// \tfloat theta = acos(dotp);\n// \tvec4 P = ((p0*sin((1.0-t)*theta) + p1*sin(t*theta)) / sin(theta));\n// \tP.w = 1.0;\n// \treturn P;\n// }\n\n// https://devcry.heiho.net/html/2017/20170521-slerp.html\n// float lerp(float a, float b, float t) {\n// \treturn (1.0 - t) * a + t * b;\n// }\n// vec4 quatSlerp(vec4 p0, vec4 p1, float t){\n// \tvec4 qb = p1;\n\n// \t// cos(a) = dot product\n// \tfloat cos_a = p0.x * qb.x + p0.y * qb.y + p0.z * qb.z + p0.w * qb.w;\n// \tif (cos_a < 0.0f) {\n// \t\tcos_a = -cos_a;\n// \t\tqb = -qb;\n// \t}\n\n// \t// close to zero, cos(a) ~= 1\n// \t// do linear interpolation\n// \tif (cos_a > 0.999) {\n// \t\treturn vec4(\n// \t\t\tlerp(p0.x, qb.x, t),\n// \t\t\tlerp(p0.y, qb.y, t),\n// \t\t\tlerp(p0.z, qb.z, t),\n// \t\t\tlerp(p0.w, qb.w, t)\n// \t\t);\n// \t}\n\n// \tfloat alpha = acos(cos_a);\n// \treturn (p0 * sin(1.0 - t) + p1 * sin(t * alpha)) / sin(alpha);\n// }\n\n// https://stackoverflow.com/questions/62943083/interpolate-between-two-quaternions-the-long-way\nvec4 quatSlerp(vec4 q1, vec4 q2, float t){\n\tfloat angle = acos(dot(q1, q2));\n\tfloat denom = sin(angle);\n\t//check if denom is zero\n\treturn (q1*sin((1.0-t)*angle)+q2*sin(t*angle))/denom;\n}\n// TO CHECK:\n// this page https://www.reddit.com/r/opengl/comments/704la7/glsl_quaternion_library/\n// has a link to a potentially nice pdf:\n// http://web.mit.edu/2.998/www/QuaternionReport1.pdf\n\n// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\nvec4 quatMult(vec4 q1, vec4 q2)\n{\n\treturn vec4(\n\tq1.w * q2.x + q1.x * q2.w + q1.z * q2.y - q1.y * q2.z,\n\tq1.w * q2.y + q1.y * q2.w + q1.x * q2.z - q1.z * q2.x,\n\tq1.w * q2.z + q1.z * q2.w + q1.y * q2.x - q1.x * q2.y,\n\tq1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n\t);\n}\n// http://glmatrix.net/docs/quat.js.html#line97\n//   let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n\n//   let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n//   out[0] = ax * bw + aw * bx + ay * bz - az * by;\n\n//   out[1] = ay * bw + aw * by + az * bx - ax * bz;\n\n//   out[2] = az * bw + aw * bz + ax * by - ay * bx;\n\n//   out[3] = aw * bw - ax * bx - ay * by - az * bz;\n\n//   return out\n\n\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n \treturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,  0.0, oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\n// https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\nvec4 quatFromAxisAngle(vec3 axis, float angle)\n{\n\tvec4 qr;\n\tfloat half_angle = (angle * 0.5); // * 3.14159 / 180.0;\n\tfloat sin_half_angle = sin(half_angle);\n\tqr.x = axis.x * sin_half_angle;\n\tqr.y = axis.y * sin_half_angle;\n\tqr.z = axis.z * sin_half_angle;\n\tqr.w = cos(half_angle);\n\treturn qr;\n}\nvec3 rotateWithAxisAngle(vec3 position, vec3 axis, float angle)\n{\n\tvec4 q = quatFromAxisAngle(axis, angle);\n\tvec3 v = position.xyz;\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n// vec3 applyQuaternionToVector( vec4 q, vec3 v ){\n// \treturn v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n// }\nvec3 rotateWithQuat( vec3 v, vec4 q )\n{\n\t// vec4 qv = multQuat( quat, vec4(vec, 0.0) );\n\t// return multQuat( qv, vec4(-quat.x, -quat.y, -quat.z, quat.w) ).xyz;\n\treturn v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n// https://github.com/glslify/glsl-look-at/blob/gh-pages/index.glsl\n// mat3 rotation_matrix(vec3 origin, vec3 target, float roll) {\n// \tvec3 rr = vec3(sin(roll), cos(roll), 0.0);\n// \tvec3 ww = normalize(target - origin);\n// \tvec3 uu = normalize(cross(ww, rr));\n// \tvec3 vv = normalize(cross(uu, ww));\n\n// \treturn mat3(uu, vv, ww);\n// }\n// mat3 rotation_matrix(vec3 target, float roll) {\n// \tvec3 rr = vec3(sin(roll), cos(roll), 0.0);\n// \tvec3 ww = normalize(target);\n// \tvec3 uu = normalize(cross(ww, rr));\n// \tvec3 vv = normalize(cross(uu, ww));\n\n// \treturn mat3(uu, vv, ww);\n// }\n\nfloat vectorAngle(vec3 start, vec3 dest){\n\tstart = normalize(start);\n\tdest = normalize(dest);\n\n\tfloat cosTheta = dot(start, dest);\n\tvec3 c1 = cross(start, dest);\n\t// We use the dot product of the cross with the Y axis.\n\t// This is a little arbitrary, but can still give a good sense of direction\n\tvec3 y_axis = vec3(0.0, 1.0, 0.0);\n\tfloat d1 = dot(c1, y_axis);\n\tfloat angle = acos(cosTheta) * sign(d1);\n\treturn angle;\n}\n\n// http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/#i-need-an-equivalent-of-glulookat-how-do-i-orient-an-object-towards-a-point-\nvec4 vectorAlign(vec3 start, vec3 dest){\n\tstart = normalize(start);\n\tdest = normalize(dest);\n\n\tfloat cosTheta = dot(start, dest);\n\tvec3 axis;\n\n\t// if (cosTheta < -1 + 0.001f){\n\t// \t// special case when vectors in opposite directions:\n\t// \t// there is no ideal rotation axis\n\t// \t// So guess one; any will do as long as it's perpendicular to start\n\t// \taxis = cross(vec3(0.0f, 0.0f, 1.0f), start);\n\t// \tif (length2(axis) < 0.01 ) // bad luck, they were parallel, try again!\n\t// \t\taxis = cross(vec3(1.0f, 0.0f, 0.0f), start);\n\n\t// \taxis = normalize(axis);\n\t// \treturn gtx::quaternion::angleAxis(glm::radians(180.0f), axis);\n\t// }\n\tif(cosTheta > (1.0 - 0.0001) || cosTheta < (-1.0 + 0.0001) ){\n\t\taxis = normalize(cross(start, vec3(0.0, 1.0, 0.0)));\n\t\tif (length(axis) < 0.001 ){ // bad luck, they were parallel, try again!\n\t\t\taxis = normalize(cross(start, vec3(1.0, 0.0, 0.0)));\n\t\t}\n\t} else {\n\t\taxis = normalize(cross(start, dest));\n\t}\n\n\tfloat angle = acos(cosTheta);\n\n\treturn quatFromAxisAngle(axis, angle);\n}\nvec4 vectorAlignWithUp(vec3 start, vec3 dest, vec3 up){\n\tvec4 rot1 = vectorAlign(start, dest);\n\tup = normalize(up);\n\n\t// Recompute desiredUp so that it's perpendicular to the direction\n\t// You can skip that part if you really want to force desiredUp\n\t// vec3 right = normalize(cross(dest, up));\n\t// up = normalize(cross(right, dest));\n\n\t// Because of the 1rst rotation, the up is probably completely screwed up.\n\t// Find the rotation between the up of the rotated object, and the desired up\n\tvec3 newUp = rotateWithQuat(vec3(0.0, 1.0, 0.0), rot1);//rot1 * vec3(0.0, 1.0, 0.0);\n\tvec4 rot2 = vectorAlign(up, newUp);\n\n\t// return rot1;\n\treturn rot2;\n\t// return multQuat(rot1, rot2);\n\t// return rot2 * rot1;\n\n}\n\n// https://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\nfloat quatToAngle(vec4 q){\n\treturn 2.0 * acos(q.w);\n}\nvec3 quatToAxis(vec4 q){\n\treturn vec3(\n\t\tq.x / sqrt(1.0-q.w*q.w),\n\t\tq.y / sqrt(1.0-q.w*q.w),\n\t\tq.z / sqrt(1.0-q.w*q.w)\n\t);\n}\n\nvec4 align(vec3 dir, vec3 up){\n\tvec3 start_dir = vec3(0.0, 0.0, 1.0);\n\tvec3 start_up = vec3(0.0, 1.0, 0.0);\n\tvec4 rot1 = vectorAlign(start_dir, dir);\n\tup = normalize(up);\n\n\t// Recompute desiredUp so that it's perpendicular to the direction\n\t// You can skip that part if you really want to force desiredUp\n\tvec3 right = normalize(cross(dir, up));\n\tif(length(right)<0.001){\n\t\tright = vec3(1.0, 0.0, 0.0);\n\t}\n\tup = normalize(cross(right, dir));\n\n\t// Because of the 1rst rotation, the up is probably completely screwed up.\n\t// Find the rotation between the up of the rotated object, and the desired up\n\tvec3 newUp = rotateWithQuat(start_up, rot1);//rot1 * vec3(0.0, 1.0, 0.0);\n\tvec4 rot2 = vectorAlign(normalize(newUp), up);\n\n\t// return rot1;\n\treturn quatMult(rot1, rot2);\n\t// return rot2 * rot1;\n\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\nuniform float time;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\nvarying vec3 v_POLY_attribute_restP;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\nvarying float v_POLY_attribute_dist;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\nvarying float v_POLY_attribute_id;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute1\nattribute float id;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\nattribute vec3 restP;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\nattribute float dist;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/instanceTransform1\nattribute vec3 instancePosition;\nattribute vec4 instanceOrientation;\n\n\n\n\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute1\n\tfloat v_POLY_attribute1_val = id;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/globals1\n\tv_POLY_globals1_uv = vec2(uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\n\tv_POLY_attribute_restP = vec3(restP);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\n\tv_POLY_attribute_dist = float(dist);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\n\tv_POLY_attribute_id = float(id);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\n\tfloat v_POLY_globals2_time = time;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/round1\n\tfloat v_POLY_round1_val = sign(v_POLY_attribute1_val)*floor(abs(v_POLY_attribute1_val)+0.5);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/floatToVec2_1\n\tvec2 v_POLY_floatToVec2_1_vec2 = vec2(v_POLY_round1_val, 56.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/random1\n\tfloat v_POLY_random1_rand = rand(v_POLY_floatToVec2_1_vec2);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance1\n\tfloat v_POLY_fitFrom01ToVariance1_val = fitFrom01ToVariance(v_POLY_random1_rand, 1.0, 0.34);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/floatToVec3_1\n\tvec3 v_POLY_floatToVec3_1_vec3 = vec3(v_POLY_fitFrom01ToVariance1_val, v_POLY_fitFrom01ToVariance1_val, v_POLY_fitFrom01ToVariance1_val);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/instanceTransform1\n\tvec3 v_POLY_instanceTransform1_position = vec3(position);\n\tv_POLY_instanceTransform1_position *= v_POLY_floatToVec3_1_vec3;\n\tv_POLY_instanceTransform1_position = rotateWithQuat( v_POLY_instanceTransform1_position, instanceOrientation );\n\tv_POLY_instanceTransform1_position += instancePosition;\n\tvec3 v_POLY_instanceTransform1_normal = vec3(normal);\n\tv_POLY_instanceTransform1_normal = rotateWithQuat( v_POLY_instanceTransform1_normal, instanceOrientation );\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/output1\n\tvec3 transformed = v_POLY_instanceTransform1_position;\n\tvec3 objectNormal = v_POLY_instanceTransform1_normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphcolor_vertex>\n// removed:\n//\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n// removed:\n//\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}","fragment":"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/colorCorrect1\n// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance2\n//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\nuniform float time;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/texture1\nuniform sampler2D v_POLY_texture_texBaseColor;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\nvarying vec3 v_POLY_attribute_restP;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\nvarying float v_POLY_attribute_dist;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\nvarying float v_POLY_attribute_id;\n\n\n\n\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\n\tvec3 v_POLY_attribute2_val = v_POLY_attribute_restP;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\n\tfloat v_POLY_attribute3_val = v_POLY_attribute_dist;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\n\tfloat v_POLY_attribute4_val = v_POLY_attribute_id;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\n\tfloat v_POLY_globals2_time = time;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/texture1\n\tvec4 v_POLY_texture1_rgba = texture2D(v_POLY_texture_texBaseColor, v_POLY_globals1_uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/vec3ToFloat1\n\tfloat v_POLY_vec3ToFloat1_y = v_POLY_attribute2_val.y;\n\tfloat v_POLY_vec3ToFloat1_z = v_POLY_attribute2_val.z;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd3\n\tfloat v_POLY_multAdd3_val = (4.6*(v_POLY_attribute3_val + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/round2\n\tfloat v_POLY_round2_val = sign(v_POLY_attribute4_val)*floor(abs(v_POLY_attribute4_val)+0.5);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd1\n\tfloat v_POLY_multAdd1_val = (1.0*(v_POLY_globals2_time + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/colorCorrect1\n\tvec4 v_POLY_colorCorrect1_out = sRGBToLinear(v_POLY_texture1_rgba);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd2\n\tfloat v_POLY_multAdd2_val = (-0.30000000000000004*(v_POLY_vec3ToFloat1_z + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/floatToVec2_2\n\tvec2 v_POLY_floatToVec2_2_vec2 = vec2(v_POLY_round2_val, 56.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/vec4ToVec3_1\n\tvec3 v_POLY_vec4ToVec3_1_vec3 = v_POLY_colorCorrect1_out.xyz;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/random2\n\tfloat v_POLY_random2_rand = rand(v_POLY_floatToVec2_2_vec2);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance2\n\tfloat v_POLY_fitFrom01ToVariance2_val = fitFrom01ToVariance(v_POLY_random2_rand, 0.0, 1.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd4\n\tfloat v_POLY_multAdd4_val = (1.0*(v_POLY_fitFrom01ToVariance2_val + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/add2\n\tfloat v_POLY_add2_sum = (v_POLY_multAdd3_val + v_POLY_multAdd4_val + 0.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd5\n\tfloat v_POLY_multAdd5_val = (1.0*(v_POLY_add2_sum + 0.0)) + 0.9;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/add1\n\tfloat v_POLY_add1_sum = (v_POLY_multAdd2_val + v_POLY_multAdd5_val + 0.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/compare2\n\tbool v_POLY_compare2_val = (v_POLY_add1_sum > v_POLY_multAdd1_val);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/twoWaySwitch1\n\tfloat v_POLY_twoWaySwitch1_val;\n\tif(v_POLY_compare2_val){\n\tv_POLY_twoWaySwitch1_val = 0.0;\n\t} else {\n\tv_POLY_twoWaySwitch1_val = 1.0;\n\t}\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/output1\n\tdiffuseColor.xyz = v_POLY_vec4ToVec3_1_vec3;\n\tdiffuseColor.a = v_POLY_twoWaySwitch1_val;\n\n\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}","customDepthMaterial.vertex":"#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance1\n//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/instanceTransform1\n\n\n// https://stackoverflow.com/questions/23793698/how-to-implement-slerp-in-glsl-hlsl\n// vec4 quatSlerp(vec4 p0, vec4 p1, float t)\n// {\n// \tfloat dotp = dot(normalize(p0), normalize(p1));\n// \tif ((dotp > 0.9999) || (dotp < -0.9999))\n// \t{\n// \t\tif (t<=0.5)\n// \t\t\treturn p0;\n// \t\treturn p1;\n// \t}\n// \tfloat theta = acos(dotp);\n// \tvec4 P = ((p0*sin((1.0-t)*theta) + p1*sin(t*theta)) / sin(theta));\n// \tP.w = 1.0;\n// \treturn P;\n// }\n\n// https://devcry.heiho.net/html/2017/20170521-slerp.html\n// float lerp(float a, float b, float t) {\n// \treturn (1.0 - t) * a + t * b;\n// }\n// vec4 quatSlerp(vec4 p0, vec4 p1, float t){\n// \tvec4 qb = p1;\n\n// \t// cos(a) = dot product\n// \tfloat cos_a = p0.x * qb.x + p0.y * qb.y + p0.z * qb.z + p0.w * qb.w;\n// \tif (cos_a < 0.0f) {\n// \t\tcos_a = -cos_a;\n// \t\tqb = -qb;\n// \t}\n\n// \t// close to zero, cos(a) ~= 1\n// \t// do linear interpolation\n// \tif (cos_a > 0.999) {\n// \t\treturn vec4(\n// \t\t\tlerp(p0.x, qb.x, t),\n// \t\t\tlerp(p0.y, qb.y, t),\n// \t\t\tlerp(p0.z, qb.z, t),\n// \t\t\tlerp(p0.w, qb.w, t)\n// \t\t);\n// \t}\n\n// \tfloat alpha = acos(cos_a);\n// \treturn (p0 * sin(1.0 - t) + p1 * sin(t * alpha)) / sin(alpha);\n// }\n\n// https://stackoverflow.com/questions/62943083/interpolate-between-two-quaternions-the-long-way\nvec4 quatSlerp(vec4 q1, vec4 q2, float t){\n\tfloat angle = acos(dot(q1, q2));\n\tfloat denom = sin(angle);\n\t//check if denom is zero\n\treturn (q1*sin((1.0-t)*angle)+q2*sin(t*angle))/denom;\n}\n// TO CHECK:\n// this page https://www.reddit.com/r/opengl/comments/704la7/glsl_quaternion_library/\n// has a link to a potentially nice pdf:\n// http://web.mit.edu/2.998/www/QuaternionReport1.pdf\n\n// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\nvec4 quatMult(vec4 q1, vec4 q2)\n{\n\treturn vec4(\n\tq1.w * q2.x + q1.x * q2.w + q1.z * q2.y - q1.y * q2.z,\n\tq1.w * q2.y + q1.y * q2.w + q1.x * q2.z - q1.z * q2.x,\n\tq1.w * q2.z + q1.z * q2.w + q1.y * q2.x - q1.x * q2.y,\n\tq1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n\t);\n}\n// http://glmatrix.net/docs/quat.js.html#line97\n//   let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n\n//   let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n//   out[0] = ax * bw + aw * bx + ay * bz - az * by;\n\n//   out[1] = ay * bw + aw * by + az * bx - ax * bz;\n\n//   out[2] = az * bw + aw * bz + ax * by - ay * bx;\n\n//   out[3] = aw * bw - ax * bx - ay * by - az * bz;\n\n//   return out\n\n\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n \treturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,  0.0, oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\n// https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\nvec4 quatFromAxisAngle(vec3 axis, float angle)\n{\n\tvec4 qr;\n\tfloat half_angle = (angle * 0.5); // * 3.14159 / 180.0;\n\tfloat sin_half_angle = sin(half_angle);\n\tqr.x = axis.x * sin_half_angle;\n\tqr.y = axis.y * sin_half_angle;\n\tqr.z = axis.z * sin_half_angle;\n\tqr.w = cos(half_angle);\n\treturn qr;\n}\nvec3 rotateWithAxisAngle(vec3 position, vec3 axis, float angle)\n{\n\tvec4 q = quatFromAxisAngle(axis, angle);\n\tvec3 v = position.xyz;\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n// vec3 applyQuaternionToVector( vec4 q, vec3 v ){\n// \treturn v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n// }\nvec3 rotateWithQuat( vec3 v, vec4 q )\n{\n\t// vec4 qv = multQuat( quat, vec4(vec, 0.0) );\n\t// return multQuat( qv, vec4(-quat.x, -quat.y, -quat.z, quat.w) ).xyz;\n\treturn v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n// https://github.com/glslify/glsl-look-at/blob/gh-pages/index.glsl\n// mat3 rotation_matrix(vec3 origin, vec3 target, float roll) {\n// \tvec3 rr = vec3(sin(roll), cos(roll), 0.0);\n// \tvec3 ww = normalize(target - origin);\n// \tvec3 uu = normalize(cross(ww, rr));\n// \tvec3 vv = normalize(cross(uu, ww));\n\n// \treturn mat3(uu, vv, ww);\n// }\n// mat3 rotation_matrix(vec3 target, float roll) {\n// \tvec3 rr = vec3(sin(roll), cos(roll), 0.0);\n// \tvec3 ww = normalize(target);\n// \tvec3 uu = normalize(cross(ww, rr));\n// \tvec3 vv = normalize(cross(uu, ww));\n\n// \treturn mat3(uu, vv, ww);\n// }\n\nfloat vectorAngle(vec3 start, vec3 dest){\n\tstart = normalize(start);\n\tdest = normalize(dest);\n\n\tfloat cosTheta = dot(start, dest);\n\tvec3 c1 = cross(start, dest);\n\t// We use the dot product of the cross with the Y axis.\n\t// This is a little arbitrary, but can still give a good sense of direction\n\tvec3 y_axis = vec3(0.0, 1.0, 0.0);\n\tfloat d1 = dot(c1, y_axis);\n\tfloat angle = acos(cosTheta) * sign(d1);\n\treturn angle;\n}\n\n// http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/#i-need-an-equivalent-of-glulookat-how-do-i-orient-an-object-towards-a-point-\nvec4 vectorAlign(vec3 start, vec3 dest){\n\tstart = normalize(start);\n\tdest = normalize(dest);\n\n\tfloat cosTheta = dot(start, dest);\n\tvec3 axis;\n\n\t// if (cosTheta < -1 + 0.001f){\n\t// \t// special case when vectors in opposite directions:\n\t// \t// there is no ideal rotation axis\n\t// \t// So guess one; any will do as long as it's perpendicular to start\n\t// \taxis = cross(vec3(0.0f, 0.0f, 1.0f), start);\n\t// \tif (length2(axis) < 0.01 ) // bad luck, they were parallel, try again!\n\t// \t\taxis = cross(vec3(1.0f, 0.0f, 0.0f), start);\n\n\t// \taxis = normalize(axis);\n\t// \treturn gtx::quaternion::angleAxis(glm::radians(180.0f), axis);\n\t// }\n\tif(cosTheta > (1.0 - 0.0001) || cosTheta < (-1.0 + 0.0001) ){\n\t\taxis = normalize(cross(start, vec3(0.0, 1.0, 0.0)));\n\t\tif (length(axis) < 0.001 ){ // bad luck, they were parallel, try again!\n\t\t\taxis = normalize(cross(start, vec3(1.0, 0.0, 0.0)));\n\t\t}\n\t} else {\n\t\taxis = normalize(cross(start, dest));\n\t}\n\n\tfloat angle = acos(cosTheta);\n\n\treturn quatFromAxisAngle(axis, angle);\n}\nvec4 vectorAlignWithUp(vec3 start, vec3 dest, vec3 up){\n\tvec4 rot1 = vectorAlign(start, dest);\n\tup = normalize(up);\n\n\t// Recompute desiredUp so that it's perpendicular to the direction\n\t// You can skip that part if you really want to force desiredUp\n\t// vec3 right = normalize(cross(dest, up));\n\t// up = normalize(cross(right, dest));\n\n\t// Because of the 1rst rotation, the up is probably completely screwed up.\n\t// Find the rotation between the up of the rotated object, and the desired up\n\tvec3 newUp = rotateWithQuat(vec3(0.0, 1.0, 0.0), rot1);//rot1 * vec3(0.0, 1.0, 0.0);\n\tvec4 rot2 = vectorAlign(up, newUp);\n\n\t// return rot1;\n\treturn rot2;\n\t// return multQuat(rot1, rot2);\n\t// return rot2 * rot1;\n\n}\n\n// https://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\nfloat quatToAngle(vec4 q){\n\treturn 2.0 * acos(q.w);\n}\nvec3 quatToAxis(vec4 q){\n\treturn vec3(\n\t\tq.x / sqrt(1.0-q.w*q.w),\n\t\tq.y / sqrt(1.0-q.w*q.w),\n\t\tq.z / sqrt(1.0-q.w*q.w)\n\t);\n}\n\nvec4 align(vec3 dir, vec3 up){\n\tvec3 start_dir = vec3(0.0, 0.0, 1.0);\n\tvec3 start_up = vec3(0.0, 1.0, 0.0);\n\tvec4 rot1 = vectorAlign(start_dir, dir);\n\tup = normalize(up);\n\n\t// Recompute desiredUp so that it's perpendicular to the direction\n\t// You can skip that part if you really want to force desiredUp\n\tvec3 right = normalize(cross(dir, up));\n\tif(length(right)<0.001){\n\t\tright = vec3(1.0, 0.0, 0.0);\n\t}\n\tup = normalize(cross(right, dir));\n\n\t// Because of the 1rst rotation, the up is probably completely screwed up.\n\t// Find the rotation between the up of the rotated object, and the desired up\n\tvec3 newUp = rotateWithQuat(start_up, rot1);//rot1 * vec3(0.0, 1.0, 0.0);\n\tvec4 rot2 = vectorAlign(normalize(newUp), up);\n\n\t// return rot1;\n\treturn quatMult(rot1, rot2);\n\t// return rot2 * rot1;\n\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\nuniform float time;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\nvarying vec3 v_POLY_attribute_restP;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\nvarying float v_POLY_attribute_dist;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\nvarying float v_POLY_attribute_id;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute1\nattribute float id;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\nattribute vec3 restP;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\nattribute float dist;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/instanceTransform1\nattribute vec3 instancePosition;\nattribute vec4 instanceOrientation;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute1\n\tfloat v_POLY_attribute1_val = id;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/globals1\n\tv_POLY_globals1_uv = vec2(uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\n\tv_POLY_attribute_restP = vec3(restP);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\n\tv_POLY_attribute_dist = float(dist);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\n\tv_POLY_attribute_id = float(id);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\n\tfloat v_POLY_globals2_time = time;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/round1\n\tfloat v_POLY_round1_val = sign(v_POLY_attribute1_val)*floor(abs(v_POLY_attribute1_val)+0.5);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/floatToVec2_1\n\tvec2 v_POLY_floatToVec2_1_vec2 = vec2(v_POLY_round1_val, 56.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/random1\n\tfloat v_POLY_random1_rand = rand(v_POLY_floatToVec2_1_vec2);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance1\n\tfloat v_POLY_fitFrom01ToVariance1_val = fitFrom01ToVariance(v_POLY_random1_rand, 1.0, 0.34);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/floatToVec3_1\n\tvec3 v_POLY_floatToVec3_1_vec3 = vec3(v_POLY_fitFrom01ToVariance1_val, v_POLY_fitFrom01ToVariance1_val, v_POLY_fitFrom01ToVariance1_val);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/instanceTransform1\n\tvec3 v_POLY_instanceTransform1_position = vec3(position);\n\tv_POLY_instanceTransform1_position *= v_POLY_floatToVec3_1_vec3;\n\tv_POLY_instanceTransform1_position = rotateWithQuat( v_POLY_instanceTransform1_position, instanceOrientation );\n\tv_POLY_instanceTransform1_position += instancePosition;\n\tvec3 v_POLY_instanceTransform1_normal = vec3(normal);\n\tv_POLY_instanceTransform1_normal = rotateWithQuat( v_POLY_instanceTransform1_normal, instanceOrientation );\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/output1\n\tvec3 transformed = v_POLY_instanceTransform1_position;\n\tvec3 objectNormal = v_POLY_instanceTransform1_normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}","customDepthMaterial.fragment":"\n// INSERT DEFINES\n\n\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/colorCorrect1\n// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance2\n//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\nuniform float time;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/texture1\nuniform sampler2D v_POLY_texture_texBaseColor;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\nvarying vec3 v_POLY_attribute_restP;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\nvarying float v_POLY_attribute_dist;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\nvarying float v_POLY_attribute_id;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\n\tvec3 v_POLY_attribute2_val = v_POLY_attribute_restP;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\n\tfloat v_POLY_attribute3_val = v_POLY_attribute_dist;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\n\tfloat v_POLY_attribute4_val = v_POLY_attribute_id;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\n\tfloat v_POLY_globals2_time = time;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/texture1\n\tvec4 v_POLY_texture1_rgba = texture2D(v_POLY_texture_texBaseColor, v_POLY_globals1_uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/vec3ToFloat1\n\tfloat v_POLY_vec3ToFloat1_y = v_POLY_attribute2_val.y;\n\tfloat v_POLY_vec3ToFloat1_z = v_POLY_attribute2_val.z;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd3\n\tfloat v_POLY_multAdd3_val = (4.6*(v_POLY_attribute3_val + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/round2\n\tfloat v_POLY_round2_val = sign(v_POLY_attribute4_val)*floor(abs(v_POLY_attribute4_val)+0.5);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd1\n\tfloat v_POLY_multAdd1_val = (1.0*(v_POLY_globals2_time + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/colorCorrect1\n\tvec4 v_POLY_colorCorrect1_out = sRGBToLinear(v_POLY_texture1_rgba);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd2\n\tfloat v_POLY_multAdd2_val = (-0.30000000000000004*(v_POLY_vec3ToFloat1_z + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/floatToVec2_2\n\tvec2 v_POLY_floatToVec2_2_vec2 = vec2(v_POLY_round2_val, 56.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/vec4ToVec3_1\n\tvec3 v_POLY_vec4ToVec3_1_vec3 = v_POLY_colorCorrect1_out.xyz;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/random2\n\tfloat v_POLY_random2_rand = rand(v_POLY_floatToVec2_2_vec2);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance2\n\tfloat v_POLY_fitFrom01ToVariance2_val = fitFrom01ToVariance(v_POLY_random2_rand, 0.0, 1.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd4\n\tfloat v_POLY_multAdd4_val = (1.0*(v_POLY_fitFrom01ToVariance2_val + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/add2\n\tfloat v_POLY_add2_sum = (v_POLY_multAdd3_val + v_POLY_multAdd4_val + 0.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd5\n\tfloat v_POLY_multAdd5_val = (1.0*(v_POLY_add2_sum + 0.0)) + 0.9;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/add1\n\tfloat v_POLY_add1_sum = (v_POLY_multAdd2_val + v_POLY_multAdd5_val + 0.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/compare2\n\tbool v_POLY_compare2_val = (v_POLY_add1_sum > v_POLY_multAdd1_val);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/twoWaySwitch1\n\tfloat v_POLY_twoWaySwitch1_val;\n\tif(v_POLY_compare2_val){\n\tv_POLY_twoWaySwitch1_val = 0.0;\n\t} else {\n\tv_POLY_twoWaySwitch1_val = 1.0;\n\t}\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/output1\n\tdiffuseColor.xyz = v_POLY_vec4ToVec3_1_vec3;\n\tdiffuseColor.a = v_POLY_twoWaySwitch1_val;\n\n\n\n\n\t// INSERT BODY\n\t// the new body lines should be added before the alphatest_fragment\n\t// so that alpha is set before (which is really how it would be set if the alphamap_fragment above was used by the material node parameters)\n\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), diffuseColor.a );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n","customDistanceMaterial.vertex":"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance1\n//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/instanceTransform1\n\n\n// https://stackoverflow.com/questions/23793698/how-to-implement-slerp-in-glsl-hlsl\n// vec4 quatSlerp(vec4 p0, vec4 p1, float t)\n// {\n// \tfloat dotp = dot(normalize(p0), normalize(p1));\n// \tif ((dotp > 0.9999) || (dotp < -0.9999))\n// \t{\n// \t\tif (t<=0.5)\n// \t\t\treturn p0;\n// \t\treturn p1;\n// \t}\n// \tfloat theta = acos(dotp);\n// \tvec4 P = ((p0*sin((1.0-t)*theta) + p1*sin(t*theta)) / sin(theta));\n// \tP.w = 1.0;\n// \treturn P;\n// }\n\n// https://devcry.heiho.net/html/2017/20170521-slerp.html\n// float lerp(float a, float b, float t) {\n// \treturn (1.0 - t) * a + t * b;\n// }\n// vec4 quatSlerp(vec4 p0, vec4 p1, float t){\n// \tvec4 qb = p1;\n\n// \t// cos(a) = dot product\n// \tfloat cos_a = p0.x * qb.x + p0.y * qb.y + p0.z * qb.z + p0.w * qb.w;\n// \tif (cos_a < 0.0f) {\n// \t\tcos_a = -cos_a;\n// \t\tqb = -qb;\n// \t}\n\n// \t// close to zero, cos(a) ~= 1\n// \t// do linear interpolation\n// \tif (cos_a > 0.999) {\n// \t\treturn vec4(\n// \t\t\tlerp(p0.x, qb.x, t),\n// \t\t\tlerp(p0.y, qb.y, t),\n// \t\t\tlerp(p0.z, qb.z, t),\n// \t\t\tlerp(p0.w, qb.w, t)\n// \t\t);\n// \t}\n\n// \tfloat alpha = acos(cos_a);\n// \treturn (p0 * sin(1.0 - t) + p1 * sin(t * alpha)) / sin(alpha);\n// }\n\n// https://stackoverflow.com/questions/62943083/interpolate-between-two-quaternions-the-long-way\nvec4 quatSlerp(vec4 q1, vec4 q2, float t){\n\tfloat angle = acos(dot(q1, q2));\n\tfloat denom = sin(angle);\n\t//check if denom is zero\n\treturn (q1*sin((1.0-t)*angle)+q2*sin(t*angle))/denom;\n}\n// TO CHECK:\n// this page https://www.reddit.com/r/opengl/comments/704la7/glsl_quaternion_library/\n// has a link to a potentially nice pdf:\n// http://web.mit.edu/2.998/www/QuaternionReport1.pdf\n\n// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\nvec4 quatMult(vec4 q1, vec4 q2)\n{\n\treturn vec4(\n\tq1.w * q2.x + q1.x * q2.w + q1.z * q2.y - q1.y * q2.z,\n\tq1.w * q2.y + q1.y * q2.w + q1.x * q2.z - q1.z * q2.x,\n\tq1.w * q2.z + q1.z * q2.w + q1.y * q2.x - q1.x * q2.y,\n\tq1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n\t);\n}\n// http://glmatrix.net/docs/quat.js.html#line97\n//   let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n\n//   let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n//   out[0] = ax * bw + aw * bx + ay * bz - az * by;\n\n//   out[1] = ay * bw + aw * by + az * bx - ax * bz;\n\n//   out[2] = az * bw + aw * bz + ax * by - ay * bx;\n\n//   out[3] = aw * bw - ax * bx - ay * by - az * bz;\n\n//   return out\n\n\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n \treturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,  0.0, oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\n// https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\nvec4 quatFromAxisAngle(vec3 axis, float angle)\n{\n\tvec4 qr;\n\tfloat half_angle = (angle * 0.5); // * 3.14159 / 180.0;\n\tfloat sin_half_angle = sin(half_angle);\n\tqr.x = axis.x * sin_half_angle;\n\tqr.y = axis.y * sin_half_angle;\n\tqr.z = axis.z * sin_half_angle;\n\tqr.w = cos(half_angle);\n\treturn qr;\n}\nvec3 rotateWithAxisAngle(vec3 position, vec3 axis, float angle)\n{\n\tvec4 q = quatFromAxisAngle(axis, angle);\n\tvec3 v = position.xyz;\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n// vec3 applyQuaternionToVector( vec4 q, vec3 v ){\n// \treturn v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n// }\nvec3 rotateWithQuat( vec3 v, vec4 q )\n{\n\t// vec4 qv = multQuat( quat, vec4(vec, 0.0) );\n\t// return multQuat( qv, vec4(-quat.x, -quat.y, -quat.z, quat.w) ).xyz;\n\treturn v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n// https://github.com/glslify/glsl-look-at/blob/gh-pages/index.glsl\n// mat3 rotation_matrix(vec3 origin, vec3 target, float roll) {\n// \tvec3 rr = vec3(sin(roll), cos(roll), 0.0);\n// \tvec3 ww = normalize(target - origin);\n// \tvec3 uu = normalize(cross(ww, rr));\n// \tvec3 vv = normalize(cross(uu, ww));\n\n// \treturn mat3(uu, vv, ww);\n// }\n// mat3 rotation_matrix(vec3 target, float roll) {\n// \tvec3 rr = vec3(sin(roll), cos(roll), 0.0);\n// \tvec3 ww = normalize(target);\n// \tvec3 uu = normalize(cross(ww, rr));\n// \tvec3 vv = normalize(cross(uu, ww));\n\n// \treturn mat3(uu, vv, ww);\n// }\n\nfloat vectorAngle(vec3 start, vec3 dest){\n\tstart = normalize(start);\n\tdest = normalize(dest);\n\n\tfloat cosTheta = dot(start, dest);\n\tvec3 c1 = cross(start, dest);\n\t// We use the dot product of the cross with the Y axis.\n\t// This is a little arbitrary, but can still give a good sense of direction\n\tvec3 y_axis = vec3(0.0, 1.0, 0.0);\n\tfloat d1 = dot(c1, y_axis);\n\tfloat angle = acos(cosTheta) * sign(d1);\n\treturn angle;\n}\n\n// http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/#i-need-an-equivalent-of-glulookat-how-do-i-orient-an-object-towards-a-point-\nvec4 vectorAlign(vec3 start, vec3 dest){\n\tstart = normalize(start);\n\tdest = normalize(dest);\n\n\tfloat cosTheta = dot(start, dest);\n\tvec3 axis;\n\n\t// if (cosTheta < -1 + 0.001f){\n\t// \t// special case when vectors in opposite directions:\n\t// \t// there is no ideal rotation axis\n\t// \t// So guess one; any will do as long as it's perpendicular to start\n\t// \taxis = cross(vec3(0.0f, 0.0f, 1.0f), start);\n\t// \tif (length2(axis) < 0.01 ) // bad luck, they were parallel, try again!\n\t// \t\taxis = cross(vec3(1.0f, 0.0f, 0.0f), start);\n\n\t// \taxis = normalize(axis);\n\t// \treturn gtx::quaternion::angleAxis(glm::radians(180.0f), axis);\n\t// }\n\tif(cosTheta > (1.0 - 0.0001) || cosTheta < (-1.0 + 0.0001) ){\n\t\taxis = normalize(cross(start, vec3(0.0, 1.0, 0.0)));\n\t\tif (length(axis) < 0.001 ){ // bad luck, they were parallel, try again!\n\t\t\taxis = normalize(cross(start, vec3(1.0, 0.0, 0.0)));\n\t\t}\n\t} else {\n\t\taxis = normalize(cross(start, dest));\n\t}\n\n\tfloat angle = acos(cosTheta);\n\n\treturn quatFromAxisAngle(axis, angle);\n}\nvec4 vectorAlignWithUp(vec3 start, vec3 dest, vec3 up){\n\tvec4 rot1 = vectorAlign(start, dest);\n\tup = normalize(up);\n\n\t// Recompute desiredUp so that it's perpendicular to the direction\n\t// You can skip that part if you really want to force desiredUp\n\t// vec3 right = normalize(cross(dest, up));\n\t// up = normalize(cross(right, dest));\n\n\t// Because of the 1rst rotation, the up is probably completely screwed up.\n\t// Find the rotation between the up of the rotated object, and the desired up\n\tvec3 newUp = rotateWithQuat(vec3(0.0, 1.0, 0.0), rot1);//rot1 * vec3(0.0, 1.0, 0.0);\n\tvec4 rot2 = vectorAlign(up, newUp);\n\n\t// return rot1;\n\treturn rot2;\n\t// return multQuat(rot1, rot2);\n\t// return rot2 * rot1;\n\n}\n\n// https://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\nfloat quatToAngle(vec4 q){\n\treturn 2.0 * acos(q.w);\n}\nvec3 quatToAxis(vec4 q){\n\treturn vec3(\n\t\tq.x / sqrt(1.0-q.w*q.w),\n\t\tq.y / sqrt(1.0-q.w*q.w),\n\t\tq.z / sqrt(1.0-q.w*q.w)\n\t);\n}\n\nvec4 align(vec3 dir, vec3 up){\n\tvec3 start_dir = vec3(0.0, 0.0, 1.0);\n\tvec3 start_up = vec3(0.0, 1.0, 0.0);\n\tvec4 rot1 = vectorAlign(start_dir, dir);\n\tup = normalize(up);\n\n\t// Recompute desiredUp so that it's perpendicular to the direction\n\t// You can skip that part if you really want to force desiredUp\n\tvec3 right = normalize(cross(dir, up));\n\tif(length(right)<0.001){\n\t\tright = vec3(1.0, 0.0, 0.0);\n\t}\n\tup = normalize(cross(right, dir));\n\n\t// Because of the 1rst rotation, the up is probably completely screwed up.\n\t// Find the rotation between the up of the rotated object, and the desired up\n\tvec3 newUp = rotateWithQuat(start_up, rot1);//rot1 * vec3(0.0, 1.0, 0.0);\n\tvec4 rot2 = vectorAlign(normalize(newUp), up);\n\n\t// return rot1;\n\treturn quatMult(rot1, rot2);\n\t// return rot2 * rot1;\n\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\nuniform float time;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\nvarying vec3 v_POLY_attribute_restP;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\nvarying float v_POLY_attribute_dist;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\nvarying float v_POLY_attribute_id;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute1\nattribute float id;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\nattribute vec3 restP;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\nattribute float dist;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/instanceTransform1\nattribute vec3 instancePosition;\nattribute vec4 instanceOrientation;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute1\n\tfloat v_POLY_attribute1_val = id;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/globals1\n\tv_POLY_globals1_uv = vec2(uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\n\tv_POLY_attribute_restP = vec3(restP);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\n\tv_POLY_attribute_dist = float(dist);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\n\tv_POLY_attribute_id = float(id);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\n\tfloat v_POLY_globals2_time = time;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/round1\n\tfloat v_POLY_round1_val = sign(v_POLY_attribute1_val)*floor(abs(v_POLY_attribute1_val)+0.5);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/floatToVec2_1\n\tvec2 v_POLY_floatToVec2_1_vec2 = vec2(v_POLY_round1_val, 56.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/random1\n\tfloat v_POLY_random1_rand = rand(v_POLY_floatToVec2_1_vec2);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance1\n\tfloat v_POLY_fitFrom01ToVariance1_val = fitFrom01ToVariance(v_POLY_random1_rand, 1.0, 0.34);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/floatToVec3_1\n\tvec3 v_POLY_floatToVec3_1_vec3 = vec3(v_POLY_fitFrom01ToVariance1_val, v_POLY_fitFrom01ToVariance1_val, v_POLY_fitFrom01ToVariance1_val);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/instanceTransform1\n\tvec3 v_POLY_instanceTransform1_position = vec3(position);\n\tv_POLY_instanceTransform1_position *= v_POLY_floatToVec3_1_vec3;\n\tv_POLY_instanceTransform1_position = rotateWithQuat( v_POLY_instanceTransform1_position, instanceOrientation );\n\tv_POLY_instanceTransform1_position += instancePosition;\n\tvec3 v_POLY_instanceTransform1_normal = vec3(normal);\n\tv_POLY_instanceTransform1_normal = rotateWithQuat( v_POLY_instanceTransform1_normal, instanceOrientation );\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/output1\n\tvec3 transformed = v_POLY_instanceTransform1_position;\n\tvec3 objectNormal = v_POLY_instanceTransform1_normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}","customDistanceMaterial.fragment":"\n// INSERT DEFINES\n\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/colorCorrect1\n// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance2\n//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\nuniform float time;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/texture1\nuniform sampler2D v_POLY_texture_texBaseColor;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\nvarying vec3 v_POLY_attribute_restP;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\nvarying float v_POLY_attribute_dist;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\nvarying float v_POLY_attribute_id;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\n\tvec3 v_POLY_attribute2_val = v_POLY_attribute_restP;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\n\tfloat v_POLY_attribute3_val = v_POLY_attribute_dist;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\n\tfloat v_POLY_attribute4_val = v_POLY_attribute_id;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\n\tfloat v_POLY_globals2_time = time;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/texture1\n\tvec4 v_POLY_texture1_rgba = texture2D(v_POLY_texture_texBaseColor, v_POLY_globals1_uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/vec3ToFloat1\n\tfloat v_POLY_vec3ToFloat1_y = v_POLY_attribute2_val.y;\n\tfloat v_POLY_vec3ToFloat1_z = v_POLY_attribute2_val.z;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd3\n\tfloat v_POLY_multAdd3_val = (4.6*(v_POLY_attribute3_val + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/round2\n\tfloat v_POLY_round2_val = sign(v_POLY_attribute4_val)*floor(abs(v_POLY_attribute4_val)+0.5);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd1\n\tfloat v_POLY_multAdd1_val = (1.0*(v_POLY_globals2_time + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/colorCorrect1\n\tvec4 v_POLY_colorCorrect1_out = sRGBToLinear(v_POLY_texture1_rgba);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd2\n\tfloat v_POLY_multAdd2_val = (-0.30000000000000004*(v_POLY_vec3ToFloat1_z + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/floatToVec2_2\n\tvec2 v_POLY_floatToVec2_2_vec2 = vec2(v_POLY_round2_val, 56.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/vec4ToVec3_1\n\tvec3 v_POLY_vec4ToVec3_1_vec3 = v_POLY_colorCorrect1_out.xyz;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/random2\n\tfloat v_POLY_random2_rand = rand(v_POLY_floatToVec2_2_vec2);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance2\n\tfloat v_POLY_fitFrom01ToVariance2_val = fitFrom01ToVariance(v_POLY_random2_rand, 0.0, 1.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd4\n\tfloat v_POLY_multAdd4_val = (1.0*(v_POLY_fitFrom01ToVariance2_val + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/add2\n\tfloat v_POLY_add2_sum = (v_POLY_multAdd3_val + v_POLY_multAdd4_val + 0.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd5\n\tfloat v_POLY_multAdd5_val = (1.0*(v_POLY_add2_sum + 0.0)) + 0.9;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/add1\n\tfloat v_POLY_add1_sum = (v_POLY_multAdd2_val + v_POLY_multAdd5_val + 0.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/compare2\n\tbool v_POLY_compare2_val = (v_POLY_add1_sum > v_POLY_multAdd1_val);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/twoWaySwitch1\n\tfloat v_POLY_twoWaySwitch1_val;\n\tif(v_POLY_compare2_val){\n\tv_POLY_twoWaySwitch1_val = 0.0;\n\t} else {\n\tv_POLY_twoWaySwitch1_val = 1.0;\n\t}\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/output1\n\tdiffuseColor.xyz = v_POLY_vec4ToVec3_1_vec3;\n\tdiffuseColor.a = v_POLY_twoWaySwitch1_val;\n\n\n\n\n\t// INSERT BODY\n\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n","customDepthDOFMaterial.vertex":"#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance1\n//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/instanceTransform1\n\n\n// https://stackoverflow.com/questions/23793698/how-to-implement-slerp-in-glsl-hlsl\n// vec4 quatSlerp(vec4 p0, vec4 p1, float t)\n// {\n// \tfloat dotp = dot(normalize(p0), normalize(p1));\n// \tif ((dotp > 0.9999) || (dotp < -0.9999))\n// \t{\n// \t\tif (t<=0.5)\n// \t\t\treturn p0;\n// \t\treturn p1;\n// \t}\n// \tfloat theta = acos(dotp);\n// \tvec4 P = ((p0*sin((1.0-t)*theta) + p1*sin(t*theta)) / sin(theta));\n// \tP.w = 1.0;\n// \treturn P;\n// }\n\n// https://devcry.heiho.net/html/2017/20170521-slerp.html\n// float lerp(float a, float b, float t) {\n// \treturn (1.0 - t) * a + t * b;\n// }\n// vec4 quatSlerp(vec4 p0, vec4 p1, float t){\n// \tvec4 qb = p1;\n\n// \t// cos(a) = dot product\n// \tfloat cos_a = p0.x * qb.x + p0.y * qb.y + p0.z * qb.z + p0.w * qb.w;\n// \tif (cos_a < 0.0f) {\n// \t\tcos_a = -cos_a;\n// \t\tqb = -qb;\n// \t}\n\n// \t// close to zero, cos(a) ~= 1\n// \t// do linear interpolation\n// \tif (cos_a > 0.999) {\n// \t\treturn vec4(\n// \t\t\tlerp(p0.x, qb.x, t),\n// \t\t\tlerp(p0.y, qb.y, t),\n// \t\t\tlerp(p0.z, qb.z, t),\n// \t\t\tlerp(p0.w, qb.w, t)\n// \t\t);\n// \t}\n\n// \tfloat alpha = acos(cos_a);\n// \treturn (p0 * sin(1.0 - t) + p1 * sin(t * alpha)) / sin(alpha);\n// }\n\n// https://stackoverflow.com/questions/62943083/interpolate-between-two-quaternions-the-long-way\nvec4 quatSlerp(vec4 q1, vec4 q2, float t){\n\tfloat angle = acos(dot(q1, q2));\n\tfloat denom = sin(angle);\n\t//check if denom is zero\n\treturn (q1*sin((1.0-t)*angle)+q2*sin(t*angle))/denom;\n}\n// TO CHECK:\n// this page https://www.reddit.com/r/opengl/comments/704la7/glsl_quaternion_library/\n// has a link to a potentially nice pdf:\n// http://web.mit.edu/2.998/www/QuaternionReport1.pdf\n\n// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\nvec4 quatMult(vec4 q1, vec4 q2)\n{\n\treturn vec4(\n\tq1.w * q2.x + q1.x * q2.w + q1.z * q2.y - q1.y * q2.z,\n\tq1.w * q2.y + q1.y * q2.w + q1.x * q2.z - q1.z * q2.x,\n\tq1.w * q2.z + q1.z * q2.w + q1.y * q2.x - q1.x * q2.y,\n\tq1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n\t);\n}\n// http://glmatrix.net/docs/quat.js.html#line97\n//   let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n\n//   let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n//   out[0] = ax * bw + aw * bx + ay * bz - az * by;\n\n//   out[1] = ay * bw + aw * by + az * bx - ax * bz;\n\n//   out[2] = az * bw + aw * bz + ax * by - ay * bx;\n\n//   out[3] = aw * bw - ax * bx - ay * by - az * bz;\n\n//   return out\n\n\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n \treturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,  0.0, oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\n// https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\nvec4 quatFromAxisAngle(vec3 axis, float angle)\n{\n\tvec4 qr;\n\tfloat half_angle = (angle * 0.5); // * 3.14159 / 180.0;\n\tfloat sin_half_angle = sin(half_angle);\n\tqr.x = axis.x * sin_half_angle;\n\tqr.y = axis.y * sin_half_angle;\n\tqr.z = axis.z * sin_half_angle;\n\tqr.w = cos(half_angle);\n\treturn qr;\n}\nvec3 rotateWithAxisAngle(vec3 position, vec3 axis, float angle)\n{\n\tvec4 q = quatFromAxisAngle(axis, angle);\n\tvec3 v = position.xyz;\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n// vec3 applyQuaternionToVector( vec4 q, vec3 v ){\n// \treturn v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n// }\nvec3 rotateWithQuat( vec3 v, vec4 q )\n{\n\t// vec4 qv = multQuat( quat, vec4(vec, 0.0) );\n\t// return multQuat( qv, vec4(-quat.x, -quat.y, -quat.z, quat.w) ).xyz;\n\treturn v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n// https://github.com/glslify/glsl-look-at/blob/gh-pages/index.glsl\n// mat3 rotation_matrix(vec3 origin, vec3 target, float roll) {\n// \tvec3 rr = vec3(sin(roll), cos(roll), 0.0);\n// \tvec3 ww = normalize(target - origin);\n// \tvec3 uu = normalize(cross(ww, rr));\n// \tvec3 vv = normalize(cross(uu, ww));\n\n// \treturn mat3(uu, vv, ww);\n// }\n// mat3 rotation_matrix(vec3 target, float roll) {\n// \tvec3 rr = vec3(sin(roll), cos(roll), 0.0);\n// \tvec3 ww = normalize(target);\n// \tvec3 uu = normalize(cross(ww, rr));\n// \tvec3 vv = normalize(cross(uu, ww));\n\n// \treturn mat3(uu, vv, ww);\n// }\n\nfloat vectorAngle(vec3 start, vec3 dest){\n\tstart = normalize(start);\n\tdest = normalize(dest);\n\n\tfloat cosTheta = dot(start, dest);\n\tvec3 c1 = cross(start, dest);\n\t// We use the dot product of the cross with the Y axis.\n\t// This is a little arbitrary, but can still give a good sense of direction\n\tvec3 y_axis = vec3(0.0, 1.0, 0.0);\n\tfloat d1 = dot(c1, y_axis);\n\tfloat angle = acos(cosTheta) * sign(d1);\n\treturn angle;\n}\n\n// http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/#i-need-an-equivalent-of-glulookat-how-do-i-orient-an-object-towards-a-point-\nvec4 vectorAlign(vec3 start, vec3 dest){\n\tstart = normalize(start);\n\tdest = normalize(dest);\n\n\tfloat cosTheta = dot(start, dest);\n\tvec3 axis;\n\n\t// if (cosTheta < -1 + 0.001f){\n\t// \t// special case when vectors in opposite directions:\n\t// \t// there is no ideal rotation axis\n\t// \t// So guess one; any will do as long as it's perpendicular to start\n\t// \taxis = cross(vec3(0.0f, 0.0f, 1.0f), start);\n\t// \tif (length2(axis) < 0.01 ) // bad luck, they were parallel, try again!\n\t// \t\taxis = cross(vec3(1.0f, 0.0f, 0.0f), start);\n\n\t// \taxis = normalize(axis);\n\t// \treturn gtx::quaternion::angleAxis(glm::radians(180.0f), axis);\n\t// }\n\tif(cosTheta > (1.0 - 0.0001) || cosTheta < (-1.0 + 0.0001) ){\n\t\taxis = normalize(cross(start, vec3(0.0, 1.0, 0.0)));\n\t\tif (length(axis) < 0.001 ){ // bad luck, they were parallel, try again!\n\t\t\taxis = normalize(cross(start, vec3(1.0, 0.0, 0.0)));\n\t\t}\n\t} else {\n\t\taxis = normalize(cross(start, dest));\n\t}\n\n\tfloat angle = acos(cosTheta);\n\n\treturn quatFromAxisAngle(axis, angle);\n}\nvec4 vectorAlignWithUp(vec3 start, vec3 dest, vec3 up){\n\tvec4 rot1 = vectorAlign(start, dest);\n\tup = normalize(up);\n\n\t// Recompute desiredUp so that it's perpendicular to the direction\n\t// You can skip that part if you really want to force desiredUp\n\t// vec3 right = normalize(cross(dest, up));\n\t// up = normalize(cross(right, dest));\n\n\t// Because of the 1rst rotation, the up is probably completely screwed up.\n\t// Find the rotation between the up of the rotated object, and the desired up\n\tvec3 newUp = rotateWithQuat(vec3(0.0, 1.0, 0.0), rot1);//rot1 * vec3(0.0, 1.0, 0.0);\n\tvec4 rot2 = vectorAlign(up, newUp);\n\n\t// return rot1;\n\treturn rot2;\n\t// return multQuat(rot1, rot2);\n\t// return rot2 * rot1;\n\n}\n\n// https://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\nfloat quatToAngle(vec4 q){\n\treturn 2.0 * acos(q.w);\n}\nvec3 quatToAxis(vec4 q){\n\treturn vec3(\n\t\tq.x / sqrt(1.0-q.w*q.w),\n\t\tq.y / sqrt(1.0-q.w*q.w),\n\t\tq.z / sqrt(1.0-q.w*q.w)\n\t);\n}\n\nvec4 align(vec3 dir, vec3 up){\n\tvec3 start_dir = vec3(0.0, 0.0, 1.0);\n\tvec3 start_up = vec3(0.0, 1.0, 0.0);\n\tvec4 rot1 = vectorAlign(start_dir, dir);\n\tup = normalize(up);\n\n\t// Recompute desiredUp so that it's perpendicular to the direction\n\t// You can skip that part if you really want to force desiredUp\n\tvec3 right = normalize(cross(dir, up));\n\tif(length(right)<0.001){\n\t\tright = vec3(1.0, 0.0, 0.0);\n\t}\n\tup = normalize(cross(right, dir));\n\n\t// Because of the 1rst rotation, the up is probably completely screwed up.\n\t// Find the rotation between the up of the rotated object, and the desired up\n\tvec3 newUp = rotateWithQuat(start_up, rot1);//rot1 * vec3(0.0, 1.0, 0.0);\n\tvec4 rot2 = vectorAlign(normalize(newUp), up);\n\n\t// return rot1;\n\treturn quatMult(rot1, rot2);\n\t// return rot2 * rot1;\n\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\nuniform float time;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\nvarying vec3 v_POLY_attribute_restP;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\nvarying float v_POLY_attribute_dist;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\nvarying float v_POLY_attribute_id;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute1\nattribute float id;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\nattribute vec3 restP;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\nattribute float dist;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/instanceTransform1\nattribute vec3 instancePosition;\nattribute vec4 instanceOrientation;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute1\n\tfloat v_POLY_attribute1_val = id;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/globals1\n\tv_POLY_globals1_uv = vec2(uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\n\tv_POLY_attribute_restP = vec3(restP);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\n\tv_POLY_attribute_dist = float(dist);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\n\tv_POLY_attribute_id = float(id);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\n\tfloat v_POLY_globals2_time = time;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/round1\n\tfloat v_POLY_round1_val = sign(v_POLY_attribute1_val)*floor(abs(v_POLY_attribute1_val)+0.5);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/floatToVec2_1\n\tvec2 v_POLY_floatToVec2_1_vec2 = vec2(v_POLY_round1_val, 56.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/random1\n\tfloat v_POLY_random1_rand = rand(v_POLY_floatToVec2_1_vec2);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance1\n\tfloat v_POLY_fitFrom01ToVariance1_val = fitFrom01ToVariance(v_POLY_random1_rand, 1.0, 0.34);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/floatToVec3_1\n\tvec3 v_POLY_floatToVec3_1_vec3 = vec3(v_POLY_fitFrom01ToVariance1_val, v_POLY_fitFrom01ToVariance1_val, v_POLY_fitFrom01ToVariance1_val);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/instanceTransform1\n\tvec3 v_POLY_instanceTransform1_position = vec3(position);\n\tv_POLY_instanceTransform1_position *= v_POLY_floatToVec3_1_vec3;\n\tv_POLY_instanceTransform1_position = rotateWithQuat( v_POLY_instanceTransform1_position, instanceOrientation );\n\tv_POLY_instanceTransform1_position += instancePosition;\n\tvec3 v_POLY_instanceTransform1_normal = vec3(normal);\n\tv_POLY_instanceTransform1_normal = rotateWithQuat( v_POLY_instanceTransform1_normal, instanceOrientation );\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/output1\n\tvec3 transformed = v_POLY_instanceTransform1_position;\n\tvec3 objectNormal = v_POLY_instanceTransform1_normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}","customDepthDOFMaterial.fragment":"\n// INSERT DEFINES\n\n\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/colorCorrect1\n// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance2\n//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}\n\n\n\n\n\n\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\nuniform float time;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/texture1\nuniform sampler2D v_POLY_texture_texBaseColor;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/globals1\nvarying vec2 v_POLY_globals1_uv;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\nvarying vec3 v_POLY_attribute_restP;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\nvarying float v_POLY_attribute_dist;\n\n// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\nvarying float v_POLY_attribute_id;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute2\n\tvec3 v_POLY_attribute2_val = v_POLY_attribute_restP;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute3\n\tfloat v_POLY_attribute3_val = v_POLY_attribute_dist;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/attribute4\n\tfloat v_POLY_attribute4_val = v_POLY_attribute_id;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/globals2\n\tfloat v_POLY_globals2_time = time;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/texture1\n\tvec4 v_POLY_texture1_rgba = texture2D(v_POLY_texture_texBaseColor, v_POLY_globals1_uv);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/vec3ToFloat1\n\tfloat v_POLY_vec3ToFloat1_y = v_POLY_attribute2_val.y;\n\tfloat v_POLY_vec3ToFloat1_z = v_POLY_attribute2_val.z;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd3\n\tfloat v_POLY_multAdd3_val = (4.6*(v_POLY_attribute3_val + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/round2\n\tfloat v_POLY_round2_val = sign(v_POLY_attribute4_val)*floor(abs(v_POLY_attribute4_val)+0.5);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd1\n\tfloat v_POLY_multAdd1_val = (1.0*(v_POLY_globals2_time + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/colorCorrect1\n\tvec4 v_POLY_colorCorrect1_out = sRGBToLinear(v_POLY_texture1_rgba);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd2\n\tfloat v_POLY_multAdd2_val = (-0.30000000000000004*(v_POLY_vec3ToFloat1_z + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/floatToVec2_2\n\tvec2 v_POLY_floatToVec2_2_vec2 = vec2(v_POLY_round2_val, 56.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/vec4ToVec3_1\n\tvec3 v_POLY_vec4ToVec3_1_vec3 = v_POLY_colorCorrect1_out.xyz;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/random2\n\tfloat v_POLY_random2_rand = rand(v_POLY_floatToVec2_2_vec2);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/fitFrom01ToVariance2\n\tfloat v_POLY_fitFrom01ToVariance2_val = fitFrom01ToVariance(v_POLY_random2_rand, 0.0, 1.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd4\n\tfloat v_POLY_multAdd4_val = (1.0*(v_POLY_fitFrom01ToVariance2_val + 0.0)) + 0.0;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/add2\n\tfloat v_POLY_add2_sum = (v_POLY_multAdd3_val + v_POLY_multAdd4_val + 0.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/multAdd5\n\tfloat v_POLY_multAdd5_val = (1.0*(v_POLY_add2_sum + 0.0)) + 0.9;\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/add1\n\tfloat v_POLY_add1_sum = (v_POLY_multAdd2_val + v_POLY_multAdd5_val + 0.0);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/compare2\n\tbool v_POLY_compare2_val = (v_POLY_add1_sum > v_POLY_multAdd1_val);\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/twoWaySwitch1\n\tfloat v_POLY_twoWaySwitch1_val;\n\tif(v_POLY_compare2_val){\n\tv_POLY_twoWaySwitch1_val = 0.0;\n\t} else {\n\tv_POLY_twoWaySwitch1_val = 1.0;\n\t}\n\t\n\t// /geo1/MAT/meshLambertBuilder_dinosaur2/output1\n\tdiffuseColor.xyz = v_POLY_vec4ToVec3_1_vec3;\n\tdiffuseColor.a = v_POLY_twoWaySwitch1_val;\n\n\n\n\n\t// INSERT BODY\n\t// the new body lines should be added before the alphatest_fragment\n\t// so that alpha is set before (which is really how it would be set if the alphamap_fragment above was used by the material node parameters)\n\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), diffuseColor.a );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n"}}};
	return loadScene_default(options);
};
